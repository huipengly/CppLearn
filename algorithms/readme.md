此目录下的代码是为了找工作笔试题准备。到时候可以直接拿来用的代码。

1.[sort](./sort)

- 冒泡排序
- 选择排序
- 插入排序
- 希尔排序
- 归并排序
- 快速排序
- 3-way快速排序
- 堆排序
- 计数排序
- 低位优先排序(lsd/Radix sort)

2.[linked list](./linkedList)

2.1 删除链表倒数第N个节点(leetcode.19)

- 第一遍遍历找到数组长度L，第二遍遍历删除L-N+1的节点
- 两个指针，快指针比慢指针快N+1

2.2 反转单向链表(leedcode.206)

- 两个指针，一个指向前一个节点，一个指向当前节点，每次将当前节点的next指向前一个节点。直到当前节点为空，返回前一个节点。
- **递归**方法：假设当前除了头节点都已经反转，只需要将头节点的下一个节点的next指向头节点即可。递归返回已经反转后的头节点。

2.3 反转双向链表

交换节点pre和next指针。返回原链表的尾节点。

2.4 打印有序链表公共部分

类似merge的过程

2.5 判断回文链表

方法1：使用栈。方法2：使用快慢指针找到终点，将后半部反转，然后比较。再恢复原始链表。

2.6 链表partition(划分)

给定一个数，将链表分为小于，等于，大于三部分。将三部分分别成为三条链表，再合并。

2.7 复制含有随机指针节点的链表(leetcode.138)

链表节点包含next和一个随机指向。深拷贝这个链表。

方法1：先拷贝链表next节点，同时建立旧节点和新节点的map，第二遍通过map来赋值新节点的random。

方法2：拷贝节点，并接在原节点后面。这样就可以通过原节点索引新节点。方法类似第一种。但是不需要新建map。

2.8 判断单链表有环

方法1：使用hashset判断，将走过的节点加入set，然后判断走的节点是否在set中，如果有，则这个点为入环点。 time: O(n), extra space: O(n)

方法2：使用快指针、慢指针。如果有环，则快指针一定会追上慢指针。当追上慢指针时，将快指针放回head，按照每回一个节点的速度，当再次相遇时，则为入环点。 extra space: O(1)

3.[array]()

3.1[螺旋打印矩阵](./array/PrintMatrixSpiralOrder.cpp)

**将微观问题从宏观角度分解**

给定一个方阵，螺旋打印其内容。例如1-16的4x4矩阵，打印为1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10。

将螺旋打印分解，打印每一圈内容 -> 打印每一圈的每一条边。

错误思考方向：有一个打印坐标，打印坐标如何移动，例如先向左移动多少，再向下。。。

3.2[矩阵旋转](./array/RotateMatrix.cpp)

**微观问题宏观思考**

给定一个方阵，将其旋转90度。

分解，旋转每一圈

3.3[z字形打印数组](./array/ZigZagPrintMatrix.cpp)

z字形分解为n条斜线，寻找斜线两个端点坐标变化趋势

3.4[在排序过的矩阵中查找数](./array/FindNumInSortedMatrix.cpp)

在排序好的矩阵中找到查找数

需要从左下角或右上角出发，这样才能使得大于、小于有确切的移动方向。比如从右上角，如果num大于matrix[i][j]，则向下移动，小于则向左移动。若在左上角则做不到

extra.笔试题

e1.[最大间隔](./sort/MaxGap.cpp)：

**桶排序**

题目：给定一个数组，求如果排序之后，相邻两数的最大差值，要求时间复杂度O(N)，且要求不能用非基于比较的排序。

N个数，N+1个桶。这样一定有一个非空桶。那么最大插值就在非空桶两侧

e2.[使用数组实现堆栈、队列](./stack&queue/StackAndQueueUseArray.cpp)

**堆栈、队列**

堆栈：一个索引变量表示下一个入栈元素存储位置。判断入栈爆栈或者出栈为空。

队列：维护三个变量，队列头、队列尾、队列大小。队列头表示第一个所在元素的位置，队列尾表示入栈位置。当队列头/尾到达数组超过末尾时，将其移动到数组头。通过size判断入栈爆栈或者出栈为空。

e3.[可返回最小值栈](./stack&queue/GetMinStack.cpp)

**堆栈**

实现一个可以获取当前栈最小值的栈。需要push,pop,popMin都为O(1)

使用两个栈，一个正常记录元素，一个栈记录当前栈内最小的元素。两个栈同步入栈，出栈。

e4.[队列和栈转换](./stack&queue/StackAndQueueConvert.cpp)

**队列、堆栈**

队列实现栈：队列N个数，将队列前N个数pop再push，最后将队列末尾实际pop出去

栈实现队列：两个栈A, B，当入栈时进入A，需要出栈操作时，若B为空，则将A中元素出栈，入B栈。再将B实际pop出去。

e5.[猫狗队列](./stack&queue/DogCatQueue.cpp)

**队列、时间戳、继承、多态、智能指针**

实现一种狗猫队列的结构，要求如下： 用户可以调用add方法将cat类或dog类的
实例放入队列中； 用户可以调用pollAll方法，将队列中所有的实例按照进队列
的先后顺序依次弹出； 用户可以调用pollDog方法，将队列中dog类的实例按照
进队列的先后顺序依次弹出； 用户可以调用pollCat方法，将队列中cat类的实
例按照进队列的先后顺序依次弹出； 用户可以调用isEmpty方法，检查队列中是
否还有dog或cat的实例； 用户可以调用isDogEmpty方法，检查队列中是否有dog
类的实例； 用户可以调用isCatEmpty方法，检查队列中是否有cat类的实例。

使用时间戳。两个队列，Cat和Dog。进入队列时记录进入的时间，两个队列最顶上谁早pollAll时出谁。

