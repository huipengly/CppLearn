此目录下的代码是为了找工作笔试题准备。到时候可以直接拿来用的代码。

1.[sort](./sort)

- 冒泡排序
- 选择排序
- 插入排序
- 希尔排序
- 归并排序
- 快速排序
- 3-way快速排序
- 堆排序
- 计数排序
- 低位优先排序(lsd/Radix sort)

2.[linked list](./linkedList)

2.1 删除链表倒数第N个节点(leetcode.19)

- 第一遍遍历找到数组长度L，第二遍遍历删除L-N+1的节点
- 两个指针，快指针比慢指针快N+1

2.2 反转单向链表(leedcode.206)

- 两个指针，一个指向前一个节点，一个指向当前节点，每次将当前节点的next指向前一个节点。直到当前节点为空，返回前一个节点。
- **递归**方法：假设当前除了头节点都已经反转，只需要将头节点的下一个节点的next指向头节点即可。递归返回已经反转后的头节点。

2.3 反转双向链表

交换节点pre和next指针。返回原链表的尾节点。

2.4 打印有序链表公共部分

类似merge的过程

2.5 判断回文链表

方法1：使用栈。方法2：使用快慢指针找到终点，将后半部反转，然后比较。再恢复原始链表。

2.6 链表partition(划分)

给定一个数，将链表分为小于，等于，大于三部分。将三部分分别成为三条链表，再合并。

2.7 复制含有随机指针节点的链表(leetcode.138)

链表节点包含next和一个随机指向。深拷贝这个链表。

方法1：先拷贝链表next节点，同时建立旧节点和新节点的map，第二遍通过map来赋值新节点的random。

方法2：拷贝节点，并接在原节点后面。这样就可以通过原节点索引新节点。方法类似第一种。但是不需要新建map。

2.8 判断单链表有无环(leetcode.140 & 141)

方法1：使用hashset判断，将走过的节点加入set，然后判断走的节点是否在set中，如果有，则这个点为入环点。 time: O(n), extra space: O(n)

方法2：使用快指针、慢指针。如果有环，则快指针一定会追上慢指针。当追上慢指针时，将快指针放回head，按照每回一个节点的速度，当再次相遇时，则为入环点。 extra space: O(1)

2.9 判断无环单链表是否相交，相交点(leetcode.160)

方法1：两重循环，判断是否有相等节点，第一个就是相交点。O(m*n)

方法2：使用set，将A链表所有节点加入set，然后判断B链表的节点是否在set，第一个出现在set的为相交点。

方法3：先判断两个链表长度，然后使两个链表从距离尾部相同距离开始移动，若有相同的，则相交。相交点为第一个相同节点。

方法4：两个指针，分别从A,B链表头出发，如果走到尾，则从另一个链表头出发。两个指针相遇时，要么在两个不相交链表的尾部，要么在相交节点的相交点。分情况讨论，即可得到原理

2.10 判断一个有环，一个无环链表是否相交

肯定不相交

2.11 判断两个有环链表是否相交

情况1：两个有环链表相交，交点在环节点前。

情况2：两个有环链表不相交

情况3：两个有环链表相交，交点在环内

情况2和情况3判断：从A链表环节点开始走，如果走回自己还未遇到B链表环节点，则为情况2，不相交。否则为情况3，相交且交点在环内。

2.12 判断两个链表是否相交

判断两个链表是否有环，然后根据情况使用2.8-2.11来做。

3.[array]()

3.1[螺旋打印矩阵](./array/PrintMatrixSpiralOrder.cpp)

**将微观问题从宏观角度分解**

给定一个方阵，螺旋打印其内容。例如1-16的4x4矩阵，打印为1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10。

将螺旋打印分解，打印每一圈内容 -> 打印每一圈的每一条边。

错误思考方向：有一个打印坐标，打印坐标如何移动，例如先向左移动多少，再向下。。。

3.2[矩阵旋转](./array/RotateMatrix.cpp)

**微观问题宏观思考**

给定一个方阵，将其旋转90度。

分解，旋转每一圈

3.3[z字形打印数组](./array/ZigZagPrintMatrix.cpp)

z字形分解为n条斜线，寻找斜线两个端点坐标变化趋势

3.4[在排序过的矩阵中查找数](./array/FindNumInSortedMatrix.cpp)

在排序好的矩阵中找到查找数

需要从左下角或右上角出发，这样才能使得大于、小于有确切的移动方向。比如从右上角，如果num大于matrix[i][j]，则向下移动，小于则向左移动。若在左上角则做不到

3.5[查找局部最大值(leetcode.162)](../leetcode/162.%20Find%20Peak%20Element/162.%20Find%20Peak%20Element.cpp)

遍历法O(n)。

二分法，在mid处看趋势，mid如果是上升趋势，则将lo变为mid；mid如果是下降趋势，则将hi改为mid。O(logn)

4.[tree]()

4.1二叉树遍历

有两种遍历方法，bfs和dfs。bfs既按层遍历。dfs分为三种，前序、中序、后序。遍历顺序如下图。

![二叉树遍历](./resources/145_transverse.png)

4.2二叉树前序、中序、后序递归遍历

递归：按照先父节点，再左子节点，再右子节点的顺序遍历二叉树。遍历过程中，前序是当第一次遇到节点时打印，中序是第二次遇到节点时打印，后序是第三次遇到节点时打印。

4.3二叉树前序非递归

栈：extra space O(n)。将根节点入栈，当栈不为空时，首先出栈并打印，再将出栈节点的不为空的右子节点和左子节点分别入栈，循环。

Morris traversal：extra space O(1)

4.4二叉树中序非递归

栈：当前节点不为空，则将当前节点入栈，并指向左子节点。当前节点为空，则弹出栈顶，打印，再将当前节点指向弹出节点的右节点。

Morris traversal

4.5二叉树后序非递归

前序遍历是中左右，后序遍历是左右中。前序修改入栈顺序可以产生中右左的程序，然后返回逆序。

4.6左神的二叉树直观打印

右中左顺序遍历，然后考虑对齐，再打印。打印的是个逆时针旋转90度的二叉树。

4.7前驱/后继节点

每个节点添加一个parent指针，指向父节点。根节点的父节点为null

中序遍历前一个节点为前驱节点，后一个节点为后继节点

1)前驱结点

如果一个节点有左节点，前驱节点为左节点的最右

如果一个节点没有左节点，向上找一个父节点，当前节点是其右子树

2)后继节点

如果一个节点有右节点，后继节点为右节点的最左

如果一个节点没有右节点，向上找一个父节点，当前节点是其左子树

4.8二叉树序列化和反序列化

4.8.1先序方式

序列化：遍历，使用!分割每个元素，使用#表示null

反序列化：将所有元素分割，依此放入队列。递归的方式，先中再左再右，使用队列元素构建二叉树。遇到#则返回空。

extra.笔试题

e1.[最大间隔](./sort/MaxGap.cpp)：

**桶排序**

题目：给定一个数组，求如果排序之后，相邻两数的最大差值，要求时间复杂度O(N)，且要求不能用非基于比较的排序。

N个数，N+1个桶。这样一定有一个非空桶。那么最大插值就在非空桶两侧

e2.[使用数组实现堆栈、队列](./stack&queue/StackAndQueueUseArray.cpp)

**堆栈、队列**

堆栈：一个索引变量表示下一个入栈元素存储位置。判断入栈爆栈或者出栈为空。

队列：维护三个变量，队列头、队列尾、队列大小。队列头表示第一个所在元素的位置，队列尾表示入栈位置。当队列头/尾到达数组超过末尾时，将其移动到数组头。通过size判断入栈爆栈或者出栈为空。

e3.[可返回最小值栈](./stack&queue/GetMinStack.cpp)

**堆栈**

实现一个可以获取当前栈最小值的栈。需要push,pop,popMin都为O(1)

使用两个栈，一个正常记录元素，一个栈记录当前栈内最小的元素。两个栈同步入栈，出栈。

e4.[队列和栈转换](./stack&queue/StackAndQueueConvert.cpp)

**队列、堆栈**

队列实现栈：队列N个数，将队列前N个数pop再push，最后将队列末尾实际pop出去

栈实现队列：两个栈A, B，当入栈时进入A，需要出栈操作时，若B为空，则将A中元素出栈，入B栈。再将B实际pop出去。

e5.[猫狗队列](./stack&queue/DogCatQueue.cpp)

**队列、时间戳、继承、多态、智能指针**

实现一种狗猫队列的结构，要求如下： 用户可以调用add方法将cat类或dog类的
实例放入队列中； 用户可以调用pollAll方法，将队列中所有的实例按照进队列
的先后顺序依次弹出； 用户可以调用pollDog方法，将队列中dog类的实例按照
进队列的先后顺序依次弹出； 用户可以调用pollCat方法，将队列中cat类的实
例按照进队列的先后顺序依次弹出； 用户可以调用isEmpty方法，检查队列中是
否还有dog或cat的实例； 用户可以调用isDogEmpty方法，检查队列中是否有dog
类的实例； 用户可以调用isCatEmpty方法，检查队列中是否有cat类的实例。

使用时间戳。两个队列，Cat和Dog。进入队列时记录进入的时间，两个队列最顶上谁早pollAll时出谁。

